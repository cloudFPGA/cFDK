// *****************************************************************************
// *
// *                             cloudFPGA
// *            All rights reserved -- Property of IBM
// *
// *----------------------------------------------------------------------------
// *
// * Title : Toplevel of the echo application in pass-through mode.
// *
// * File    : RoleEchoPassThrough.v
// *
// * Created : Apr. 2018
// * Authors : Francois Abel <fab@zurich.ibm.com>
// *
// * Devices : xcku060-ffva1156-2-i
// * Tools   : Vivado v2017.4 (64-bit)
// * Depends : None
// *
// * Description : This version of the role implements an echo application made
// *    of a UDP loopback and a TCP loopback connections. The role is said to be
// *    operating in "pass-through" mode because every received packet is sent
// *    back without being stored by the role.          
// * 
// * Infos & Conventions:
// *    <pi> stands for "PortIn". 
// *    <po> stands for "PortOut".
// *    <pi><SRC>_<Itf1>_<Itf1.1>_<Itf1.1.1>_tdata stands for the "data" signals
// *         of an Axi4-Stream generated by the source (i.e. master) "SRC", out
// *         of its interface "Itf1" and its sub-interfaces "Itf1.1" and 
// *         "Itf1.1.1".
// *
// *****************************************************************************


`timescale 1 ns / 1 ps

// *****************************************************************************
// **  MODULE - ECHO PASS-TRHOUGH ROLE FOR FMKU60
// *****************************************************************************

module Role_x1Udp_x1Tcp_x2Mp  // RoleEchoPassThrough
(

    //------------------------------------------------------
    //-- SHELL / Global Input Clock and Reset Interface
    //------------------------------------------------------
    input wire         piSHL_156_25Clk,
    input wire         piSHL_156_25Rst,

    //--------------------------------------------------------
    //-- SHELL / Role / Nts0 / Udp Interface
    //--------------------------------------------------------
    //---- Input AXI-Write Stream Interface --------
    input wire [63:0]  piSHL_Rol_Nts0_Udp_Axis_tdata,
    input wire [7:0]   piSHL_Rol_Nts0_Udp_Axis_tkeep,
    input wire [0:0]   piSHL_Rol_Nts0_Udp_Axis_tlast,
    input wire         piSHL_Rol_Nts0_Udp_Axis_tvalid,
    output wire        poROL_Shl_Nts0_Udp_Axis_tready,
    //---- Output AXI-Write Stream Interface ---------
    input wire         piSHL_Rol_Nts0_Udp_Axis_tready,
    output wire [63:0] poROL_Shl_Nts0_Udp_Axis_tdata,
    output wire [7:0]  poROL_Shl_Nts0_Udp_Axis_tkeep,
    output wire [0:0]  poROL_Shl_Nts0_Udp_Axis_tlast,
    output wire        poROL_Shl_Nts0_Udp_Axis_tvalid
 
);


// *****************************************************************************
// **  STRUCTURE
// *****************************************************************************

  //============================================================================
  //  SIGNAL (i.e. WIRES & REGISTERS) DECLARATIONS
  //============================================================================
 
  //-- SHELL/Udp --> ROLE/Udp ------------------------------
  reg         sROL_Shl_Nts0_Udp_Axis_tready;
  reg [63:0]  sSHL_Rol_Nts0_Udp_Axis_tdata;
  reg [ 7:0]  sSHL_Rol_Nts0_Udp_Axis_tkeep;
  reg         sSHL_Rol_Nts0_Udp_Axis_tvalid;
  reg         sSHL_Rol_Nts0_Udp_Axis_tlast;
  //-- ROLE/Udp --> SHELL/Udp ------------------------------
  reg  [63:0]  sROL_Shl_Nts0_Udp_Axis_tdata;
  reg  [ 7:0]  sROL_Shl_Nts0_Udp_Axis_tkeep;
  reg          sROL_Shl_Nts0_Udp_Axis_tlast;
  reg          sROL_Shl_Nts0_Udp_Axis_tvalid;
  reg          sSHL_Rol_Nts0_Udp_Axis_tready;
  
  //-- SHELL/Tcp --> ROLE/Tcp ------------------------------
  reg         sROL_Shl_Nts0_Tcp_Axis_tready;
  reg [63:0]  sSHL_Rol_Nts0_Tcp_Axis_tdata;
  reg [ 7:0]  sSHL_Rol_Nts0_Tcp_Axis_tkeep;
  reg         sSHL_Rol_Nts0_Tcp_Axis_tvalid;
  reg         sSHL_Rol_Nts0_Tcp_Axis_tlast;
  //-- ROLE/Tcp --> SHELL/Tcp ------------------------------
  reg  [63:0]  sROL_Shl_Nts0_Tcp_Axis_tdata;
  reg  [ 7:0]  sROL_Shl_Nts0_Tcp_Axis_tkeep;
  reg          sROL_Shl_Nts0_Tcp_Axis_tlast;
  reg          sROL_Shl_Nts0_Tcp_Axis_tvalid;
  reg          sSHL_Rol_Nts0_Tcp_Axis_tready;
  
  //------------------------------------------------------------------------------------------------
  //-- PROC: ECHO PASS-THROUGH UDP
  //--  Implements an echo application (i.e. loopback) between the Rx and Tx ports of the UDP
  //--  connection. The echo is said to operate in "pass-through" mode because every received
  //--  packet is sent back without being stored by the role.
  //------------------------------------------------------------------------------------------------
  always@(posedge(piSHL_156_25Clk)) begin
    if (piSHL_156_25Rst) begin
      // Initialize the 'sSHL_Rol_Nts0_Udp_Axis' register
      sSHL_Rol_Nts0_Udp_Axis_tdata   <= 64'd0;
      sSHL_Rol_Nts0_Udp_Axis_tkeep   <=  8'd0;
      sSHL_Rol_Nts0_Udp_Axis_tlast   <=  1'b0;
      sSHL_Rol_Nts0_Udp_Axis_tvalid  <=  1'b0;
      sSHL_Rol_Nts0_Udp_Axis_tready  <=  1'b1;
    end
    else begin
      if (piSHL_Rol_Nts0_Udp_Axis_tready == 1'b1) begin
        // Load a new Axis chunk into the 'sSHL_Rol_Nts0_Udp_Axis' register 
        sSHL_Rol_Nts0_Udp_Axis_tdata  <= piSHL_Rol_Nts0_Udp_Axis_tdata;
        sSHL_Rol_Nts0_Udp_Axis_tkeep  <= piSHL_Rol_Nts0_Udp_Axis_tkeep;
        sSHL_Rol_Nts0_Udp_Axis_tlast  <= piSHL_Rol_Nts0_Udp_Axis_tlast;
        sSHL_Rol_Nts0_Udp_Axis_tvalid <= piSHL_Rol_Nts0_Udp_Axis_tvalid;
        sSHL_Rol_Nts0_Udp_Axis_tready <= piSHL_Rol_Nts0_Udp_Axis_tready;
      end
    end
  end

  //------------------------------------------------------------------------------------------------
  //-- COMB: CONTINUOUS OUTPUT PORT ASSIGNMENTS
  //------------------------------------------------------------------------------------------------
  assign poROL_Shl_Nts0_Udp_Axis_tdata  = sSHL_Rol_Nts0_Udp_Axis_tdata;
  assign poROL_Shl_Nts0_Udp_Axis_tkeep  = sSHL_Rol_Nts0_Udp_Axis_tkeep;
  assign poROL_Shl_Nts0_Udp_Axis_tlast  = sSHL_Rol_Nts0_Udp_Axis_tlast;
  assign poROL_Shl_Nts0_Udp_Axis_tvalid = sSHL_Rol_Nts0_Udp_Axis_tvalid;
  assign poROL_Shl_Nts0_Udp_Axis_tready = sSHL_Rol_Nts0_Udp_Axis_tready;
  
  
  //------------------------------------------------------------------------------------------------
  //-- PROC: ECHO PASS-THROUGH TCP
  //--  Implements an echo application (i.e. loopback) between the Rx and Tx ports of the TCP
  //--  connection. The echo is said to operate in "pass-through" mode because every received
  //--  packet is sent back without being stored by the role.
  //------------------------------------------------------------------------------------------------
  always@(posedge(piSHL_156_25Clk)) begin
    if (piSHL_156_25Rst) begin
      // Initialize the 'sSHL_Rol_Nts0_Tcp_Axis' register
      sSHL_Rol_Nts0_Tcp_Axis_tdata   <= 64'd0;
      sSHL_Rol_Nts0_Tcp_Axis_tkeep   <=  8'd0;
      sSHL_Rol_Nts0_Tcp_Axis_tlast   <=  1'b0;
      sSHL_Rol_Nts0_Tcp_Axis_tvalid  <=  1'b0;
      sSHL_Rol_Nts0_Tcp_Axis_tready  <=  1'b1;
    end
    else begin
      if (piSHL_Rol_Nts0_Tcp_Axis_tready == 1'b1) begin
        // Load a new Axis chunk into the 'sSHL_Rol_Nts0_Tcp_Axis' register 
        sSHL_Rol_Nts0_Tcp_Axis_tdata  <= piSHL_Rol_Nts0_Tcp_Axis_tdata;
        sSHL_Rol_Nts0_Tcp_Axis_tkeep  <= piSHL_Rol_Nts0_Tcp_Axis_tkeep;
        sSHL_Rol_Nts0_Tcp_Axis_tlast  <= piSHL_Rol_Nts0_Tcp_Axis_tlast;
        sSHL_Rol_Nts0_Tcp_Axis_tvalid <= piSHL_Rol_Nts0_Tcp_Axis_tvalid;
        sSHL_Rol_Nts0_Tcp_Axis_tready <= piSHL_Rol_Nts0_Tcp_Axis_tready;
      end
   end
  end
  
  //------------------------------------------------------------------------------------------------
  //-- COMB: CONTINUOUS OUTPUT PORT ASSIGNMENTS
  //------------------------------------------------------------------------------------------------
  assign poROL_Shl_Nts0_Tcp_Axis_tdata  = sSHL_Rol_Nts0_Tcp_Axis_tdata;
  assign poROL_Shl_Nts0_Tcp_Axis_tkeep  = sSHL_Rol_Nts0_Tcp_Axis_tkeep;
  assign poROL_Shl_Nts0_Tcp_Axis_tlast  = sSHL_Rol_Nts0_Tcp_Axis_tlast;
  assign poROL_Shl_Nts0_Tcp_Axis_tvalid = sSHL_Rol_Nts0_Tcp_Axis_tvalid;
  assign poROL_Shl_Nts0_Tcp_Axis_tready = sSHL_Rol_Nts0_Tcp_Axis_tready;
endmodule

