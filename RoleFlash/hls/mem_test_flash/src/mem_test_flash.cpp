// *****************************************************************************
// *
// *                             cloudFPGA
// *            All rights reserved -- Property of IBM
// *
// *----------------------------------------------------------------------------
// *
// * Title : Toplevel of the echo application in store-and-forward mode.
// *
// * File    : echo_store_and_forward.cpp
// *
// * Created : Apr. 2018
// * Authors : Francois Abel <fab@zurich.ibm.com>
// *
// * Devices : xcku060-ffva1156-2-i
// * Tools   : Vivado v2017.4 (64-bit)
// * Depends : None
// *
// * Description : This role application implements an echo loopback on the UDP
// *   and TCP connections. The application is said to be operating in
// *   "store-and-forward" mode because every received packet is first stored
// *   in the DDR4 before being read from that memory and being sent back.
// *
// * Infos & Remarks:
// *   The SHELL provides two logical memory ports for the ROLE to access
// *   a physical channel of the DDR4. The interfaces of these two ports enable
// *   high throughput transfer of data between the AXI4 memory-mapped domain of
// *   the DDR4 and the AXI4-Stream domains of the ROLE. The interfaces are
// *   based on an underlying AXI-DataMover-IP from Xilinx which provides
// *   specific Memory-Map-to-Stream (MM2S) and a Stream-to-Memory-Map (S2MM)
// *   channels for handling the transaction between the two domains.
// *   For more details, refer to Xilinx/LogiCORE-IP-Product-Guide (PG022).
// *
// * Conventions:
// *   <pi> stands for "PortIn".
// *   <po> stands for "PortOut".
// *   <si> stands for "StreamIn".
// *   <so> stands for "StreamOut".
// *   <si><SRC>_<Itf1>_<Itf1.1>_<Itf1.1.1>_tdata stands for the "data" signals
// *        of an Axi4-Stream generated by the source (i.e. master) "SRC", out
// *        of its interface "Itf1" and its sub-interfaces "Itf1.1" and
// *        "Itf1.1.1".
// *
// *****************************************************************************

#include "mem_test_flash.hpp"

using namespace std;
using namespace hls;

ap_uint<8> fsmState = FSM_IDLE;
bool runContiniously = false;
ap_uint<1> wasError = 0;
ap_uint<32> lastCheckedAddress = 0;
ap_uint<32> currentPatternAdderss = 0;
ap_uint<64> currentMemPattern = 0;
ap_uint<32> patternWriteNum = 0;

/*****************************************************************************/
/* @brief     Counts the number of 1s an 8-bit value.
 * @ingroup   RoleEchoHls
 *
 * @param[in] keepVal is the parameter to check.
 *
 * @return    The number of bit set in the .
 *****************************************************************************/
ap_uint<4> keepToLen(ap_uint<8> keepVal) {
  ap_uint<4> count = 0;

  switch(keepVal){
    case 0x01: count = 1; break;
    case 0x03: count = 2; break;
    case 0x07: count = 3; break;
    case 0x0F: count = 4; break;
    case 0x1F: count = 5; break;
    case 0x3F: count = 6; break;
    case 0x7F: count = 7; break;
    case 0xFF: count = 8; break;
  }
  return (count);
}

ap_uint<8> STS_to_Vector(DmSts sts)
{
  ap_uint<8> ret = 0;
  ret |= sts.tag;
  ret |= ((ap_uint<8>) sts.interr) << 4;
  ret |= ((ap_uint<8>) sts.decerr) << 5;
  ret |= ((ap_uint<8>) sts.slverr) << 6;
  ret |= ((ap_uint<8>) sts.okay)   << 7;
  return ret;
}


/*****************************************************************************/
/* @brief   Main process of the ECHO application.
 * @ingroup RoleEchoHls
 *
 * @param[in]     siUdp is the incoming UDP stream (from SHELL/Nts)
 * @param[out]    soUdp is the outgoing UDP stream (to   SHELL/Nts)
 * @param[in]     siTcp is the incoming TCP stream (from SHELL/Nts)
 * @param[out]    soTcp is the outgoing TCP stream (to   SHELL/Nts)
 * @param[out]    soMemRdCmd0 is the outgoing memory read command for port 0
 * @param[in]     siMemRdSts0 is the incoming memory read status for port 0
 * @param[in]     siMemRead0  is the incoming data read from port 0
 * @param[out]    soMemWrCmd0 is the outgoing memory write command for port 0
 * @param[in]     siMemWrSts0 is the incoming memory write status for port 0
 * @param[out]    soMemWrite0 is the outgoing data write for port 0
 * @param[out]    soMemRdCmd1 is the outgoing memory read command for port 1
 * @param[in]     siMemRdSts1 is the incoming memory read status for port 1
 * @param[in]     siMemRead1  is the incoming data read from port 1
 * @param[out]    soMemWrCmd1 is the outgoing memory write command for port 1
 * @param[in]     siMemWrSts1 is the incoming memory write status for port 1
 * @param[out]    soMemWrite1 is the outgoing data write for port 1
 *
 * @return { description of the return value }.
 *****************************************************************************/

void mem_test_flash_main(

    // ----- system reset ---
    ap_uint<1> sys_reset,
    // ----- MMIO ------
    ap_uint<2> DIAG_CTRL_IN,
    ap_uint<2> *DIAG_STAT_OUT,

    // ---- add. Debug output ----
    ap_uint<16> *debug_out,

    //------------------------------------------------------
    //-- SHELL / Role / Mem / Mp0 Interface
    //------------------------------------------------------
    //---- Read Path (MM2S) ------------
    stream<DmCmd>       &soMemRdCmdP0,
    stream<DmSts>       &siMemRdStsP0,
    stream<Axis<512 > > &siMemReadP0,
    //---- Write Path (S2MM) -----------
    stream<DmCmd>       &soMemWrCmdP0,
    stream<DmSts>       &siMemWrStsP0,
    stream<Axis<512> >  &soMemWriteP0

    ) 
{

#pragma HLS INTERFACE ap_vld register port=sys_reset name=piSysReset
#pragma HLS INTERFACE ap_vld register port=DIAG_CTRL_IN name=piMMIO_diag_ctrl
#pragma HLS INTERFACE ap_ovld register port=DIAG_STAT_OUT name=poMMIO_diag_stat
#pragma HLS INTERFACE ap_ovld register port=debug_out name=poDebug

  // Bundling: SHELL / Role / Mem / Mp0 / Read Interface
#pragma HLS INTERFACE axis register both port=soMemRdCmdP0
#pragma HLS INTERFACE axis register both port=siMemRdStsP0
#pragma HLS INTERFACE axis register both port=siMemReadP0

#pragma HLS DATA_PACK variable=soMemRdCmdP0 instance=soMemRdCmdP0
#pragma HLS DATA_PACK variable=siMemRdStsP0 instance=siMemRdStsP0

  // Bundling: SHELL / Role / Mem / Mp0 / Write Interface
#pragma HLS INTERFACE axis register both port=soMemWrCmdP0
#pragma HLS INTERFACE axis register both port=siMemWrStsP0
#pragma HLS INTERFACE axis register both port=soMemWriteP0

#pragma HLS DATA_PACK variable=soMemWrCmdP0 instance=soMemWrCmdP0
#pragma HLS DATA_PACK variable=siMemWrStsP0 instance=siMemWrStsP0


#pragma HLS INTERFACE ap_ctrl_none port=return

//#pragma HLS DATAFLOW //interval=1

  Axis<512>     memP0;
  DmSts         memRdStsP0;
  DmSts         memWrStsP0;
  ap_uint<16>   debugVec = 0;

  if(sys_reset == 1)
  {
    fsmState = FSM_IDLE;
    runContiniously = false;
    wasError = 0;
    lastCheckedAddress = 0;
    currentPatternAdderss = 0;
    currentMemPattern = 0;
    patternWriteNum = 0;
    return;
  }


  switch(fsmState) {

    case FSM_IDLE:
      switch(DIAG_CTRL_IN) {
        case 0x3: //reserved --> idle
        case 0x0: //stay IDLE, stop test
          *DIAG_STAT_OUT = (0 << 1) | wasError;
          runContiniously = false;
          lastCheckedAddress = MEM_START_ADDR;
          break; 
        case 0x2: 
          runContiniously = true;
          //NO break
        case 0x1: //Run once
          if (lastCheckedAddress == MEM_START_ADDR)
          { // start new test
            wasError = 0;
            lastCheckedAddress = MEM_START_ADDR;
            fsmState = FSM_WR_PAT_CMD;
            *DIAG_STAT_OUT = 0b10;
            debugVec = 0;
          } else if(lastCheckedAddress >= MEM_END_ADDR)
          {//checked space completely once
            if (runContiniously)
            {
              fsmState = FSM_WR_PAT_CMD;
              lastCheckedAddress = MEM_START_ADDR;
              *DIAG_STAT_OUT = (1 << 1) | wasError;
            } else { //stay here
              fsmState = FSM_IDLE;
              *DIAG_STAT_OUT = (0 << 1) | wasError;
            }
          } else { //continue current run
            fsmState = FSM_WR_PAT_CMD;
            *DIAG_STAT_OUT = (1 << 1) | wasError;
          }
          break;
      }
      break;

    case FSM_WR_PAT_CMD:
      if (!soMemWrCmdP0.full()) {
        if(lastCheckedAddress == MEM_START_ADDR)
        {
          currentPatternAdderss = MEM_START_ADDR;
        } else {
          currentPatternAdderss = lastCheckedAddress+1;
        }
        //-- Post a memory write command to SHELL/Mem/Mp0
        soMemWrCmdP0.write(DmCmd(currentPatternAdderss, CHECK_CHUNK_SIZE));
        currentMemPattern = 0;
        patternWriteNum = 0;
        fsmState = FSM_WR_PAT_DATA;
      }
      break;

    case FSM_WR_PAT_DATA:
      if (!soMemWriteP0.full()) {
        //-- Assemble a memory word and write it to DRAM
        currentMemPattern++;
        memP0.tdata = (currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern);
        memP0.tkeep = (0xFF, 0xFF, 0xFF, 0xFF,0xFF, 0xFF, 0xFF, 0xFF);

        if(patternWriteNum == CHECK_CHUNK_SIZE/64) //64 Bytes per write
        {
          memP0.tlast = 1;
          fsmState = FSM_WR_PAT_STS;
        } else {
          memP0.tlast = 0;
        }
        soMemWriteP0.write(memP0);
        patternWriteNum++;
      }
      break;

    case FSM_WR_PAT_STS:
      if (!siMemWrStsP0.empty()) {
        //-- Get the memory write status for Mem/Mp0
        siMemWrStsP0.read(memWrStsP0);
        //latch errors
        debugVec |= (ap_uint<16>) STS_to_Vector(memWrStsP0);
        fsmState = FSM_RD_PAT_CMD;
      }
      break;

    case FSM_RD_PAT_CMD:
      if (!soMemRdCmdP0.full()) {
        //-- Post a memory read command to SHELL/Mem/Mp0
        soMemRdCmdP0.write(DmCmd(currentPatternAdderss, CHECK_CHUNK_SIZE));
        currentMemPattern = 0;
        fsmState = FSM_RD_PAT_DATA;
      }
      break;

    case FSM_RD_PAT_DATA:
      if (!siMemReadP0.empty()) {
        //-- Read a memory word from DRAM
        siMemReadP0.read(memP0);
        currentMemPattern++;
        if (memP0.tdata != ((ap_uint<512>) (currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern,currentMemPattern)) )
        {
          printf("error in pattern reading!\n");
          wasError = true;
        }
        if (memP0.tkeep != (0xFF, 0xFF, 0xFF, 0xFF,0xFF, 0xFF, 0xFF, 0xFF))
        {
          printf("error in tkeep\n");
        }
        //I trust that there will be a tlast (so no counting)
        if (memP0.tlast)
        {
          fsmState = FSM_RD_PAT_STS;
        }
      }
      break;

    case FSM_RD_PAT_STS:
      if (!siMemRdStsP0.empty()) {
        //-- Get the memory read status for Mem/Mp0
        siMemRdStsP0.read(memRdStsP0);
        //latch errors
        debugVec |= ((ap_uint<16>) STS_to_Vector(memRdStsP0) )<< 8;
        fsmState = FSM_WR_ANTI_CMD;
      }
      break;

    case FSM_WR_ANTI_CMD:
      if (!soMemWrCmdP0.full()) {
        if(lastCheckedAddress == MEM_START_ADDR)
        {
          currentPatternAdderss = MEM_START_ADDR;
        } else {
          currentPatternAdderss = lastCheckedAddress+1;
        }
        //-- Post a memory write command to SHELL/Mem/Mp0
        soMemWrCmdP0.write(DmCmd(currentPatternAdderss, CHECK_CHUNK_SIZE));
        currentMemPattern = 0;
        patternWriteNum = 0;
        fsmState = FSM_WR_ANTI_DATA;
      }
      break;

    case FSM_WR_ANTI_DATA:
      if (!soMemWriteP0.full()) {
        //-- Assemble a memory word and write it to DRAM
        currentMemPattern++;
        memP0.tdata = (~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern);
        memP0.tkeep = (0xFF, 0xFF, 0xFF, 0xFF,0xFF, 0xFF, 0xFF, 0xFF);

        if(patternWriteNum == CHECK_CHUNK_SIZE/64) //64 Bytes per write
        {
          memP0.tlast = 1;
          fsmState = FSM_WR_ANTI_STS;
        } else {
          memP0.tlast = 0;
        }
        soMemWriteP0.write(memP0);
        patternWriteNum++;
      }
      break;

    case FSM_WR_ANTI_STS:
      if (!siMemWrStsP0.empty()) {
        //-- Get the memory write status for Mem/Mp0
        siMemWrStsP0.read(memWrStsP0);
        //latch errors
        debugVec |= (ap_uint<16>) STS_to_Vector(memWrStsP0);
        fsmState = FSM_RD_ANTI_CMD;
      }
      break;

    case FSM_RD_ANTI_CMD:
      if (!soMemRdCmdP0.full()) {
        //-- Post a memory read command to SHELL/Mem/Mp0
        soMemRdCmdP0.write(DmCmd(currentPatternAdderss, CHECK_CHUNK_SIZE));
        currentMemPattern = 0;
        fsmState = FSM_RD_ANTI_DATA;
      }
      break;

    case FSM_RD_ANTI_DATA:
      if (!siMemReadP0.empty()) {
        //-- Read a memory word from DRAM
        siMemReadP0.read(memP0);
        currentMemPattern++;
        if (memP0.tdata != ((ap_uint<512>) (~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern,~currentMemPattern)) )
        {
          printf("error in antipattern reading!\n");
          wasError = true;
        }
        if (memP0.tkeep != (0xFF, 0xFF, 0xFF, 0xFF,0xFF, 0xFF, 0xFF, 0xFF))
        {
          printf("error in tkeep\n");
        }
        //I trust that there will be a tlast (so no counting)
        if (memP0.tlast)
        {
          fsmState = FSM_RD_ANTI_STS;
        }
      }
      break;

    case FSM_RD_ANTI_STS:
      if (!siMemRdStsP0.empty()) {
        //-- Get the memory read status for Mem/Mp0
        siMemRdStsP0.read(memRdStsP0);
        //latch errors
        debugVec |= ((ap_uint<16>) STS_to_Vector(memRdStsP0) )<< 8;
        lastCheckedAddress = currentPatternAdderss+CHECK_CHUNK_SIZE;
        fsmState = FSM_IDLE;
      }
      break;

  }  // End: switch

  *debug_out = debugVec;

  return;
}
