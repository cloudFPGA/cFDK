/************************************************
Copyright (c) 2016-2019, IBM Research.
Copyright (c) 2015, Xilinx, Inc.

All rights reserved.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
************************************************/

/*****************************************************************************
 * @file       : AxisPsd4.hpp
 * @brief      : A class to access the fields of a TCP/IPv4 or UDP/IPv4 pseudo
 *               packet when transmitted over an AXI4-Stream interface.
 *
 * System:     : cloudFPGA
 * Component   : Shell, Network Transport Session (NTS)
 * Language    : Vivado HLS
 *
 *----------------------------------------------------------------------------
 *
 * @details : The TCP/UDP pseudo IPv4 packet fields defined in this class
 *  refer tp the format generated by the 10GbE MAC of Xilinx which organizes
 *  its two 64-bit Rx and Tx interfaces into 8 lanes (see PG157). 
 *  The result of this division into lanes, is that the ETH fields end up
 *  being stored in LITTLE-ENDIAN order instead of the initial big-endian
 *  order used to transmit bytes over the physical media.
 *  As an example, assume that the 16-bits field "TotalLength" of an IPv4
 *  packet has a value of '0x1234'. This field will be transmitted on the
 *  media in big-endian order .i.e, a '0x12' followed by '0x34'. However,
 *  this field will end up being ordered in little-endian mode (.i.e, 0x3412)
 *  by the AXI4-Stream interface of the 10GbE MAC.
 *
 *  Therefore, the mapping of a pseudo IPv4 packet onto an  AXI4-Stream
 *  interface encoded in LITTLE-ENDIAN is as follows:
 *
 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Destination Address                        |                       Source Address                          |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *                                                                  |       UDP or TCP Length       |    Protocol   |     0x00      |    
 *                                                                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * 
 *  And the format of a TCP segment over a pseudo IPV4 packet is as follow:
 *
 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Destination Address                        |                       Source Address                          |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |       Destination Port        |          Source Port          |       UDP or TCP Length       |    Protocol   |     0x00      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Acknowledgment Number                      |                        Sequence Number                        |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                               |                               |                               |   |U|A|P|R|S|F|  Data |       |
 *  |         Urgent Pointer        |           Checksum            |            Window             |   |R|C|S|S|Y|I| Offset|  Res  |
 *  |                               |                               |                               |   |G|K|H|T|N|N|       |       |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                                                             Data                                                              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *  And the format of a UDP datagram over a pseudo IPv4 packet is as follows:

 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Destination Address                        |                       Source Address                          |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |       Destination Port        |          Source Port          |       UDP or TCP Length       |    Protocol   |     0x00      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                             Data                              |           Checksum            |           Length              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                                                             Data                                                              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *****************************************************************************/

#ifndef AXIS_PSD4_H_
#define AXIS_PSD4_H_


/***********************************************************
 * PSD4 - PSEUDO-HEADER SIZE
 *  A pseudo IP4 packet has a default header size of 12 bytes.
 ***********************************************************/
#define PSD4_HEADER_SIZE     12      // In bytes

/***********************************************************
 * PSD4 - PSEUDO-HEADER FIELDS IN LITTLE-ENDIAN (LE) ORDER
 ***********************************************************/
//OBSOLETE typedef ap_uint<32> LE_Pd4SrcAddr;   // Pseudo IPv4 Source Address in little-endian order
//typedef ap_uint<32> LE_Pd4DstAddr;   // Pseudo IPv4 Destination Address in little-endian order
//typedef ap_uint<32> LE_Pd4Address;   // Pseudo IPv4 Source or Destination Address in little-endian order
//typedef ap_uint<32> LE_Pd44Addr;     // Pseudo IPv4 Source or Destination Address in little-endian order
//typedef ap_uint< 8> LE_Psd4Zero;     // Pseudo IPv4 Zero bits
//typedef ap_uint< 8> LE_Psd4Prot;     // Pseudo IPv4 Protocol
//typedef ap_uint<16> LE_Psd4Len;      // Pseudo IPv4 UDP or TCP Length in little-endian order

/***********************************************************
 * PSD4 - PSEUDO-HEADER FIELDS IN NETWORK BYTE ORDER
 ***********************************************************/
//OBSOLETE typedef ap_uint<32> Psd4SrcAddr;     // Pseudo IPv4 Source Address
//typedef ap_uint<32> Psd4DstAddr;     // Pseudo-Header Destination Address
//typedef ap_uint<32> Psd4Address;     // Pseudo-Header Source or Destination Address
//typedef ap_uint<32> Psd4Addr;        // Pseudo-Header Source or Destination Address
typedef ap_uint< 8> Psd4Res;           // Pseudo-Header Reserved Bits
//typedef ap_uint< 8> Psd4Prot;        // Pseudo-Header Protocol
typedef ap_uint<16> Psd4Len;           // Pseudo-Header UDP datagram or TCP segment Length


/******************************************************************************
 * PSD4 - PSEUDO-IPv4 Packet over AXI4-STREAMING
 *  As Encoded by the 10GbE MAC (.i.e LITTLE-ENDIAN order).
 *******************************************************************************/
class AxisPsd4: public AxiWord {

  public:
    AxisPsd4() {}
    AxisPsd4(AxiWord axiWord) :
      AxiWord(axiWord.tdata, axiWord.tkeep, axiWord.tlast) {}
    AxisPsd4(ap_uint<64> tdata, ap_uint<8> tkeep, ap_uint<1> tlast) :
      AxiWord(tdata, tkeep, tlast) {}

    //-----------------------------------------------------
    //-- PSD4 - PSEUDO-IP4 PACKET - Constant Definitions
    //-----------------------------------------------------
    // IP protocol numbers
    //static const unsigned char  TCP_PROTOCOL  = 0x06;
    //static const unsigned char  UDP_PROTOCOL  = 0x11;

    //-----------------------------------------------------
    //-- PSD4 - PSEUDO-IP4 PACKET - Setters and Getters
    //-----------------------------------------------------
    // Set-Get the PSD4 Source Address
    void        setPsd4SrcAddr(Ip4Addr addr)    {                  tdata.range(31,  0) = swapDWord(addr); }
    Ip4Addr     getPsd4SrcAddr()                { return swapDWord(tdata.range(31,  0));                  }
    // Set-Get the PSD4 Destination Address
    void        setPsd4DstAddr(Ip4Addr addr)    {                  tdata.range(63, 32) = swapDWord(addr); }
    Ip4Addr     getPsd4DstAddr()                { return swapDWord(tdata.range(63, 32));                  }
    // Set-Get the PSD4 Reserved Bits
    void        setPsd4ResBits(Psd4Res res)     {                  tdata.range( 7,  0) = res;             }
    Psd4Res     getPsd4ResBits()                {           return tdata.range( 7,  0);                   }
    // Set-Get the PSD4 Protocol
    void        setPsd4Prot(Ip4Prot prot)       {                  tdata.range(15,  8) = prot;            }
    Ip4Prot     getPsd4Prot()                   {           return tdata.range(15,  8);                   }
    // Set-Get the PSD4 LY4 Length
    void        setPsd4Len(Psd4Len len)         {                  tdata.range(31, 16) = swapWord(len);   }
    Psd4Len     getPsd4Len()                    { return swapWord (tdata.range(31, 16));                  }


    //-----------------------------------------------------
    //-- ENCAPSULATED TCP SEGMENT - Setters and Getters
    //-----------------------------------------------------
    // Set-Get the TCP Source Port
    void        setTcpSrcPort(TcpPort port)     {                  tdata.range(47, 32) = swapWord(port);  }
    TcpPort     getTcpSrcPort()                 { return swapWord (tdata.range(47, 32));                  }
    // Set-Get the TCP Destination Port
    void        setTcpDstPort(TcpPort port)     {                  tdata.range(63, 48) = swapWord(port);  }
    TcpPort     getTcpDstPort()                 { return swapWord (tdata.range(63, 48));                  }
    // Set-Get the TCP Sequence Number
    void        setTcpSeqNum(TcpSeqNum num)     {                  tdata.range(31,  0) = swapDWord(num);  }
    TcpSeqNum   getTcpSeqNum()                  { return swapDWord(tdata.range(31,  0));                  }
    // Set-Get the TCP Acknowledgment Number
    void        setTcpAckNum(TcpAckNum num)     {                  tdata.range(63, 32) = swapDWord(num);  }
    TcpAckNum   getTcpAckNum()                  { return swapDWord(tdata.range(63, 32));                  }
    // Set-Get the TCP Data Offset
    void        setTcpDataOff(TcpDataOff offset){                  tdata.range( 7,  4) = offset;          }
    TcpDataOff  getTcpDataOff()                 { return           tdata.range( 7,  4);                   }
    // Set-Get the TCP Control Bits
    void setTcpCtrlFin(TcpCtrlBit bit)          {                  tdata.bit( 8) = bit;                   }
    TcpCtrlBit  getTcpCtrlFin()                 {           return tdata.bit( 8);                         }
    void setTcpCtrlSyn(TcpCtrlBit bit)          {                  tdata.bit( 9) = bit;                   }
    TcpCtrlBit  getTcpCtrlSyn()                 {           return tdata.bit( 9);                         }
    void setTcpCtrlRst(TcpCtrlBit bit)          {                  tdata.bit(10) = bit;                   }
    TcpCtrlBit  getTcpCtrlRst()                 {           return tdata.bit(10);                         }
    void setTcpCtrlPsh(TcpCtrlBit bit)          {                  tdata.bit(11) = bit;                   }
    TcpCtrlBit  getTcpCtrlPsh()                 {           return tdata.bit(11);                         }
    void setTcpCtrlAck(TcpCtrlBit bit)          {                  tdata.bit(12) = bit;                   }
    TcpCtrlBit  getTcpCtrlAck()                 {           return tdata.bit(12);                         }
    void setTcpCtrlUrg(TcpCtrlBit bit)          {                  tdata.bit(13) = bit;                   }
    TcpCtrlBit  getTcpCtrlUrg()                 {           return tdata.bit(13);                         }
    // Set-Get the TCP Window
    void        setTcpWindow(TcpWindow win)     {                  tdata.range(31, 16) = swapWord(win);   }
    TcpWindow   getTcpWindow()                  { return swapWord (tdata.range(31, 16));                  }
    // Set-Get the TCP Checksum
    void        setTcpChecksum(TcpChecksum csum){                  tdata.range(47, 32) = swapWord(csum);  }
    TcpChecksum getTcpChecksum()                { return swapWord (tdata.range(47, 32));                  }
    // Set-Get the TCP Urgent Pointer
    void        setTcpUrgPtr(TcpUrgPtr ptr)     {                  tdata.range(63, 48) = swapWord(ptr);   }
    TcpUrgPtr   getTcpUrgPtr()                  { return swapWord (tdata.range(63, 48));                  }
    // Set-Get the TCP Options
    void        setTcpOptKind(TcpOptKind val)   {                  tdata.range( 7,  0);                   }
    TcpOptKind  getTcpOptKind()                 { return           tdata.range( 7,  0);                   }
    void        setTcpOptMss(TcpOptMss val)     {                  tdata.range(31, 16);                   }
    TcpOptMss   getTcpOptMss()                  { return swapWord (tdata.range(31, 16));                  }

    LE_TcpPort  getLE_TcpSrcPort()              {           return tdata.range(47, 32) ;                  }
    LE_TcpPort  getLE_TcpDstPort()              {           return tdata.range(63, 48);                   }

    //-----------------------------------------------------
    //-- ENCAPSULATED UDP DATAGRAM - Setters and Getters
    //-----------------------------------------------------
    // Set-Get the UDP Source Port
    void        setUdpSrcPort(UdpPort port)     {                  tdata.range(47, 32) = swapWord(port);  }
    UdpPort     getUdpSrcPort()                 { return swapWord (tdata.range(47, 32));                  }
    // Set-Get the UDP Destination Port
    void        setUdpDstPort(UdpPort port)     {                  tdata.range(63, 48) = swapWord(port);  }
    UdpPort     getUdpDstPort()                 { return swapWord (tdata.range(63, 48));                  }

    // Set-Get the UDP Length
    void        setUdpLen(UdpLen len)           {                  tdata.range(15,  0) = swapWord(len);   }
    UdpLen      getUdpLen()                     { return swapWord (tdata.range(15,  0));                  }
    // Set-Get the UDP Checksum
    void        setUdpCsum(UdpCsum csum)        {                  tdata.range(31, 16) = swapWord(csum);  }
    TcpChecksum getUdpCsum()                    { return swapWord (tdata.range(31, 16));                  }

  private:
    // Swap the two bytes of a word (.i.e, 16 bits)
    ap_uint<16> swapWord(ap_uint<16> inpWord) {
        return (inpWord.range(7,0), inpWord.range(15, 8));
    }
    // Swap the four bytes of a double-word (.i.e, 32 bits)
    ap_uint<32> swapDWord(ap_uint<32> inpDWord) {
        return (inpDWord.range( 7, 0), inpDWord.range(15,  8),
                inpDWord.range(23,16), inpDWord.range(31, 24));
    }

}; // End of: AxisPsd4

#endif
