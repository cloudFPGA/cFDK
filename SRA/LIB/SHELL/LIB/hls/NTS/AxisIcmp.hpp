/*******************************************************************************
 * Copyright 2016 -- 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/


/*******************************************************************************
 * @file       : AxisIcmp.hpp
 * @brief      : A class to access ICMP header fields within data chunks
 *               transmitted over an AXI4-Stream interface.
 *
 * System:     : cloudFPGA
 * Component   : Shell, Network Transport Stack (NTS)
 * Language    : Vivado HLS
 *
 *------------------------------------------------------------------------------
 *
 * @details : The Internet Control Message Protocol (ICMP) fields defined in
 *  this class refer to the format generated by the 10GbE MAC of Xilinx which
 *  organizes its two 64-bit Rx and Tx interfaces into 8 lanes (see PG157).
 *  The result of this division into lanes, is that the ICMP fields end up
 *  being stored in LITTLE-ENDIAN order instead of the initial big-endian
 *  order used to transmit bytes over the physical media.
 *  As an example, assume that the 16 bits of the ICMP "Checksum" packet has
 *  a value of '0xA1B2'. This field will be transmitted on the media in big-
 *  endian order .i.e, a '0xA1' followed by '0xB2'. However, this field will
 *  end up being ordered in little-endian mode (.i.e, 0xB2A1) by the AXI4-
 *  Stream interface of the 10GbE MAC.
 *
 * @warning : This class is to be used when an ICMP packet is aligned to a
 *  64-bit quadword. Refer to the methods of 'AxisIp4.hpp' to access the
 *  fields of an ICMP packet that is embedded into an IPv4 packet, or the
 *  the methods of 'AxisEth.hpp' to access the fields of an ICMP packet that
 *  is embedded into IPv4 into an Ethernet frame.
 *
 * @info :
 *  The format of an ICMP packet transferred over an AXI4-Stream interface of
 *  quadwords is done in LITTLE-ENDIAN and is mapped as follows:
 *
 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Rest of Header (Part-Hi)                   |           Checksum            |      Code     |     Type      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                        Data                                   |                 Rest of Header (Part-Lo)
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                                                             Data                                                              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * \ingroup NTS
 * \addtogroup NTS
 * \{
 *******************************************************************************/

#ifndef _AXIS_ICMP_H_
#define _AXIS_ICMP_H_

#include "./AxisRaw.hpp"

/*********************************************************
 * ICMP - HEADER LEN.
 *  All ICMP packets have an 8-byte header and a variable-
 *  len data section.The first 4 bytes of the header have
 *  a fixed format, while the last 4 bytes depend on the
 *  type/code of the ICMP packet.
 *********************************************************/
#define ICMP_HEADER_LEN     8       // In bytes

/*********************************************************
 * ICMP - HEADER FIELDS IN LITTLE_ENDIAN (LE) ORDER.
 *********************************************************/
typedef ap_uint< 8> LE_IcmpType;    // ICMP Type of control Message
typedef ap_uint< 8> LE_IcmpCode;    // ICMP subtype of control Message
typedef ap_uint<16> LE_IcmpCsum;    // ICMP header and data Checksum

/*********************************************************
 * ICMP - HEADER FIELDS IN NETWORK BYTE ORDER.
 *   Default Type Definitions (as used by HLS)
 *********************************************************/
typedef ap_uint< 8> IcmpType;       // ICMP Type of control Message
typedef ap_uint< 8> IcmpCode;       // ICMP subtype of control Message
typedef ap_uint<16> IcmpCsum;       // ICMP header and data Checksum
typedef ap_uint<16> IcmpIdent;      // ICMP identifier
typedef ap_uint<16> IcmpSeqNum;     // ICMP sequence number


/*********************************************************
 * ICMP Data over AXI4-STREAMING
 *  As Encoded by the 10GbE MAC (.i.e LITTLE-ENDIAN order).
 *********************************************************/
class AxisIcmp: public AxisRaw {

  public:
    AxisIcmp() {}
    AxisIcmp(AxisRaw axisRaw) :
        AxisRaw(axisRaw.getLE_TData(), axisRaw.getLE_TKeep(), axisRaw.getLE_TLast()) {}
    AxisIcmp(LE_tData tdata, LE_tKeep tkeep, LE_tLast tlast) :
        AxisRaw(tdata, tkeep, tlast) {}
    AxisIcmp(const AxisIcmp &axisIcmp) :
        AxisRaw(axisIcmp.tdata, axisIcmp.tkeep, axisIcmp.tlast) {}

    /****************************************************************
     * ICMP MESSAGE HEADER HELPERS
     ****************************************************************/

    // Set-Get the message Type field
    void          setIcmpType(IcmpType type)         {                    tdata.range( 7,  0) = type;            }
    IcmpType      getIcmpType()                      {             return tdata.range( 7,  0);                   }
    // Set-Get the message Code field
    void          setIcmpCode(IcmpCode code)         {                    tdata.range(15,  8) = code;            }
    IcmpCode      getIcmpCode()                      {             return tdata.range(15,  8);                   }
    // Set-Get the Checksum field
    void          setIcmpCsum(IcmpCsum csum)         {                    tdata.range(31, 16) = swapWord(csum);  }
    IcmpCsum      getIcmpCsum()                      {   return swapWord (tdata.range(31, 16));                  }
    // Set-Get the Identifier field
    void          setIcmpIdent(IcmpIdent id)         {                    tdata.range(47, 32) = swapWord(id);    }
    IcmpIdent     getIcmpIdent()                     {   return swapWord (tdata.range(47, 32));                  }
    // Set-Get the Sequence Number field
    void          setIcmpSeqNum(IcmpSeqNum num)      {                    tdata.range(63, 48) = swapWord(num);   }
    IcmpSeqNum    getIcmpSeqNum()                    {   return swapWord (tdata.range(63, 48));                  }

  private:
    // Swap the two bytes of a word (.i.e, 16 bits)
    ap_uint<16> swapWord(ap_uint<16> inpWord) {
      return (inpWord.range(7,0), inpWord.range(15, 8));
    }
    // Swap the four bytes of a double-word (.i.e, 32 bits)
    ap_uint<32> swapDWord(ap_uint<32> inpDWord) {
      return (inpDWord.range( 7, 0), inpDWord.range(15,  8),
              inpDWord.range(23,16), inpDWord.range(31, 24));
    }

}; // End of: AxisArp

#endif

/*! \} */
