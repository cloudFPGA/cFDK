/************************************************
Copyright (c) 2016-2019, IBM Research.
Copyright (c) 2015, Xilinx, Inc.

All rights reserved.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
************************************************/

/*****************************************************************************
 * @file       : AxisRaw.hpp
 * @brief      : A generic class used by the Network-Transport-Stack (NTS) to
 *               to tranfer a chunk of data  over an AXI4-Stream interface.
 *
 * System:     : cloudFPGA
 * Component   : Shell, Network Transport Session (NTS)
 * Language    : Vivado HLS
 *
 *----------------------------------------------------------------------------
 *
 * @details : This class is similar to the original 'AxiWord' class and is
 *  expected to slowly replace it over time. The major difference lies in the
 *  members 'tdata', 'tkeep' and 'tlast' of this class being protected.
 *
 *  @Warning: The order of the bytes of the 'tdata' member is aligned with the
 *   format generated by the 10GbE MAC of Xilinx which organizes its two 64-bit
 *   Rx and Tx interfaces into 8 lanes (see PG157). The result of this division
 *   into lanes happens to store the 'tdata' member into LITTLE-ENDIAN (LE)
 *   order instead of the initial BID-ENDIAN (BE) order used to transmit bytes
 *   over the physical media.
 *   As an example, consider the 16-bit field "EtherType" of the ETH frame which
 *   value is '0x0800' when the Ethernet frame contains an IPv4 packet. This
 *   field will be transmitted on the media in big-endian order .i.e, a '0x08'
 *   byte followed by a '0x00' byte. However, this field will end up being
 *   ordered in little-endian mode (.i.e, 0x0080) by the AXI4-Stream interface
 *   of the 10GbE MAC.
 *
 *  Therefore, the mapping of a network stream of bytes onto an 64-bits AXIS_RAW
 *  interface in LITTLE-ENDIAN is as follows:
 *
 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |     B[07]     |     B[06]     |     B[05]     |     B[04]     |     B[03]     |     B[02]     |     B[01]     |     B[00]     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*   |     B[15]     |     B[14]     |     B[13]     |     B[12]     |     B[11]     |     B[10]     |     B[09]     |     B[08]     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *
 *
 *****************************************************************************/

#ifndef AXIS_RAW_H_
#define AXIS_RAW_H_

//#include "./AxisArp.hpp"
//#include "./AxisIp4.hpp"


/*******************************************************************************
 * GENERIC AXI4 STREAMING INTERFACES
 *******************************************************************************/
template<int D>
   class Axis {
     private:
       ap_uint<D>       tdata;
       ap_uint<(D+7)/8> tkeep;
       ap_uint<1>       tlast;
       Axis() {}
       Axis(ap_uint<D> single_data) :
           tdata((ap_uint<D>)single_data), tkeep(~(((ap_uint<D>) single_data) & 0)), tlast(1) {}
   };

/***********************************************
 * AXIS RAW WIDTH
 ***********************************************/
#define AXIS_ROW_WIDTH_AT_10GE  64
#define ARW                     AXIS_ROW_WIDTH_AT_10GE

/***********************************************
 * AXIS_RAW - TYPE FIELDS DEFINITION
 *   FYI - 'LE' stands for Little-Endian order.
 ***********************************************/
typedef ap_uint<ARW>   LE_tData;
typedef ap_uint<ARW/2> LE_tDataHalf;
typedef ap_uint<ARW/8> LE_tKeep;
typedef ap_uint<1>     LE_tLast; // Just for consistancy
typedef ap_uint<ARW>   tData;
typedef ap_uint<ARW/2> tDataHalf;
typedef ap_uint<ARW/8> tKeep;
typedef ap_uint<1>     tLast;

/******************************************************************************
 * AXIS_RAW - RAW AXIS-4 STREAMING INTERFACE
 *  An AxisRaw is logically divided into 'ARW/8' bytes. The validity of a given
 *  byte is qualified by the 'tkeep' field, while the assertion of the 'tlast'
 *  bit indicates the end of a stream.
 *
 * @Warning: Members of this class are kept public for compatibility issues with
 *  the legacy code.
 *
 * @TODO-This class is currently hard-coded with AWR=64 --> Make it generic
 ******************************************************************************/
class AxisRaw {

  public:
    LE_tData    tdata;
    LE_tKeep    tkeep;
    LE_tLast    tlast;

  public:
    AxisRaw()       {}
    AxisRaw(LE_tData tdata, LE_tKeep tkeep, LE_tLast tlast) :
            tdata(tdata), tkeep(tkeep), tlast(tlast) {}

    // Return the number of valid bytes
    int keepToLen() {
        switch(this->tkeep){
            case 0x01: return 1; break;
            case 0x03: return 2; break;
            case 0x07: return 3; break;
            case 0x0F: return 4; break;
            case 0x1F: return 5; break;
            case 0x3F: return 6; break;
            case 0x7F: return 7; break;
            case 0xFF: return 8; break;
        }
        return 0;
    }

    /******************************************************
     * BIG-ENDIAN SETTERS AND GETTERS
     *****************************************************/
    // Set the tdata field in Big-Endian order
    void setTData(tData data) {
        tdata.range(63,  0) = byteSwap64(data);
    }
    // Return the tdata field in Big-Endian order
    tData getTData() {
         return byteSwap64(tdata.range(63, 0));
    }
    // Set the upper-half part of the tdata field in Big-Endian order
    void setTDataHi(tData data) {  // FIXME
        tdata.range(63, 32) = byteSwap32(data.range(63, 32));
    }
    // Return the upper-half part of the tdata field in Big-Endian order
    tDataHalf getTDataHi() {
        return byteSwap32(tdata.range(63, 32));  // FIXME: Swap then range
    }
    // Set the lower-half part of the tdata field in Big-Endian order
    void setTDataLo(tData data) {  // FIXME: Swap then range
        tdata.range(31,  0) = byteSwap32(data.range(31,  0));
    }
    // Return the lower-half part of the tdata field in Big-Endian order
    tDataHalf getTDataLo() {  // FIXME: Swap then range
        return byteSwap32(tdata.range(31,  0));
    }
    // Set the tkeep field with respect to the data field in Big-Endian order
    void setTKeep(tKeep keep) {
        // [FIXME-ENABLE-WHEN-REFACTORED]  tkeep = bitSwap8(keep);
        tkeep = keep;
    }
    // Get the tkeep field with respect to the data field in Big-Endian order
    tKeep getTKeep() {
        // [FIXME-ENABLE-WHEN-REFACTORED] return bitSwap8(tkeep);
        return tkeep;
    }
    // Set the tlast field
    void setTLast(tLast last) {
        tlast = last;
    }
    // Get the tlast bit
    tLast getTLast() {
        return tlast;
    }
    /******************************************************
     * LITTLE-ENDIAN SETTERS AND GETTERS
     *****************************************************/
    // Set the tdata field in Little-Endian order
    void setLE_TData(LE_tData data) {
        tdata.range(63,  0) = data;
    }
    // Return the tdata field in Little-Endian order
    LE_tData getLE_TData() {
        return tdata.range(63, 0);
    }
    // Set the upper-half part of the tdata field in Little-Endian order
    void setLE_TDataHi(LE_tData data) {
        tdata.range(63, 32) = data.range(63, 32);
    }
    // Return the upper-half part of the tdata field in Little-Endian order
    LE_tDataHalf getLE_TDataHi() {
        return tdata.range(63, 32);
    }
    // Set the lower-half part of the tdata field in Little-Endian order
    void setLE_TDataLo(LE_tData data) {
        tdata.range(31,  0) = data.range(31,  0);
    }
    // Return the lower-half part of the tdata field in Little-Endian order
    LE_tDataHalf getLE_TDataLo() {
        return tdata.range(31,  0);
    }
    // Set the tkeep field with respect to the data field in Little-Endian order
    void setLE_TKeep(LE_tKeep keep) {
        tkeep = keep;
    }
    // Get the tkeep field with respect to the data field in Little-Endian order
    LE_tKeep getLE_TKeep() {
        return tkeep;
    }
    // Set the tlast field
    void setLE_TLast(LE_tLast last) {
        tlast = last;
    }
    // Get the tlast bit
    LE_tLast getLE_TLast() {
        return tlast;
    }


    // Assess the consistency of 'tkeep' and 'tlast'
    bool isValid() {
    	if (((this->tlast == 0) and (this->tkeep != 0xFF)) or
    	    ((this->tlast == 1) and (this->keepToLen() == 0))) {
    		return false;
    	}
    	return true;
    }

  private:
    // Reverse the bits within a byte.
    ap_uint<8> bitSwap8(ap_uint<8> inputVector) {
        return (inputVector.range(0,7));
    }
    // Swap the two bytes of a word (.i.e, 16 bits).
    ap_uint<16> byteSwap16(ap_uint<16> inputVector) {
        return (inputVector.range(7,0), inputVector(15, 8));
    }
    // Swap the four bytes of a double-word (.i.e, 32 bits).
    ap_uint<32> byteSwap32(ap_uint<32> inpDWord) {
        return (inpDWord.range( 7, 0), inpDWord.range(15,  8),
                inpDWord.range(23,16), inpDWord.range(31, 24));
    }
    // Swap the eight bytes of a quad-word (.i.e, 64 bits).
    ap_uint<64> byteSwap64(ap_uint<64> inpQWord) {
        return (inpQWord.range( 7, 0), inpQWord(15,  8),
                inpQWord.range(23,16), inpQWord(31, 24),
                inpQWord.range(39,32), inpQWord(47, 40),
                inpQWord.range(55,48), inpQWord(63, 56));
    }
};

#endif
