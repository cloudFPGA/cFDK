/*
 * Copyright 2016 -- 2020 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * @file       : AxisRaw.hpp
 * @brief      : A generic class used by the Network-Transport-Stack (NTS) to
 *               to transfer a chunk of data  over an AXI4-Stream interface.
 *
 * System:     : cloudFPGA
 * Component   : Shell, Network Transport Stack (NTS)
 * Language    : Vivado HLS
 *
 *------------------------------------------------------------------------------
 *
 * @details : This class was initially designed as a Super class with derivation
 *  in mind for Sub classes such as 'AxisEth', 'AxisIp4', 'AxisTcp' and so on.
 *  Unfortunatelly, class inheritance no longer works after Vivado 17.4 and the
 *  transition from '#pragma HLS resource core=AXI4Stream' to '#pragma HLS
 *  INTERFACE axis'. Therefore, the entire code of this class had to be copied
 *  in each and every sub-classes :-(
 *
 *  @warning: The order of the bytes of the 'tdata' member is aligned with the
 *   format generated by the 10GbE MAC of Xilinx which organizes its two 64-bit
 *   Rx and Tx interfaces into 8 lanes (see PG157). The result of this division
 *   into lanes happens to store the 'tdata' member into LITTLE-ENDIAN (LE)
 *   order instead of the initial BID-ENDIAN (BE) order used to transmit bytes
 *   over the physical media.
 *   As an example, consider the 16-bit field "EtherType" of the ETH frame which
 *   value is '0x0800' when the Ethernet frame contains an IPv4 packet. This
 *   field will be transmitted on the media in big-endian order .i.e, a '0x08'
 *   byte followed by a '0x00' byte. However, this field will end up being
 *   ordered in little-endian mode (.i.e, 0x0080) by the AXI4-Stream interface
 *   of the 10GbE MAC.
 *
 *  Therefore, the mapping of a network stream of bytes onto a 64-bits AXIS_RAW
 *  interface in LITTLE-ENDIAN is as follows:
 *
 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |     B[07]     |     B[06]     |     B[05]     |     B[04]     |     B[03]     |     B[02]     |     B[01]     |     B[00]     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*   |     B[15]     |     B[14]     |     B[13]     |     B[12]     |     B[11]     |     B[10]     |     B[09]     |     B[08]     |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * @info: What's this Little-Endian(LE) vs Big-Endian(BE) anyhow.
 *  FYI - The original source from Xilinx (available at:
 *   https://github.com/Xilinx/HLx_Examples/tree/master/Acceleration/tcp_ip) is
 *   entirely coded with respect to the above mapping of the media network
 *   stream  over a 64-bits interface in little-endian oder. This makes the
 *   initial code particularly difficult to read, maintain and test. Therefore,
 *   this class implements a few methods to access the AXIS data streams as if
 *   they were encoded in the expected big-endian order.
 *     All of this headache could have been avoided if the original code had
 *   swapped the 64-bits bus to/from the Ethernet MAC. This enhancement will be
 *   implemented if/when we will move to a higher data rate (.e.g 25GE or 100GE).
 *   Until then, here is a graphical helper to visualize the LE<->BE relation:
 *
 *                    Lower-Half                     Higher-Half
 *         +---------------+---------------+---------------+---------------+
 *  LITTLE |63   (L-L)   48|47   (L-H)   32|31   (H-L)   16|15   (H-H)    0|
 *         +---------------+---------------+---------------+---------------+
 *               /|\             /|\             /|\             /|\
 *                +---------------|---------------|---------------|-+
 *                                +---------------|-+             | |
 *                                  +-------------+ |             | |
 *                  +---------------|---------------|-------------+ |
 *                 \|/             \|/             \|/             \|/
 *         +---------------+---------------+---------------+---------------+
 *     BIG |63   (H-H)   48|47   (H-L)   32|31   (L-H)   16|15   (L-L)    0|
 *         +---------------+---------------+---------------+---------------+
 *                   Higher-Half                      Lower-Half
 *
 *
 *         +---------------+---------------+---------------+---------------+
 *  LITTLE |63        Lower-Half         32|31       Higher-Half          0|
 *         +---------------+---------------+---------------+---------------+
 *                          /|\                         /|\
 *                           +---------------------------|--+
 *                         +-----------------------------+  |
 *                        \|/                              \|/
 *         +---------------+---------------+---------------+---------------+
 *     BIG |63       Higher-Half         32|31        Lower-Half          0|
 *         +---------------+---------------+---------------+---------------+
 *
 * \ingroup NTS
 * \addtogroup NTS
 * \{
 *******************************************************************************/

#ifndef _AXIS_RAW_H_
#define _AXIS_RAW_H_

#include "ap_int.h"

/***********************************************
 * AXIS RAW - DEFINITIONS
 ***********************************************/
#define AXIS_ROW_WIDTH_AT_10GE  64
#define ARW                     AXIS_ROW_WIDTH_AT_10GE

#define TLAST       1

/***********************************************
 * AXIS_RAW - TYPE FIELDS DEFINITION
 *   FYI - 'LE' stands for Little-Endian order.
 ***********************************************/
typedef ap_uint<ARW>    LE_tData;
typedef ap_uint<ARW/2>  LE_tDataHalf;
typedef ap_uint<ARW/8>  LE_tKeep;
typedef ap_uint<1>      LE_tLast; // Added for consistency
typedef ap_uint<ARW>    tData;
typedef ap_uint<ARW/2>  tDataHalf;
typedef ap_uint<ARW/8>  tKeep;
typedef ap_uint<ARW/16> tKeepHalf;
typedef ap_uint<1>      tLast;

/*******************************************************************************
 * AXIS_RAW - RAW AXIS-4 STREAMING INTERFACE
 *  An AxisRaw is logically divided into 'ARW/8' bytes. The validity of a given
 *  byte is qualified by the 'tkeep' field, while the assertion of the 'tlast'
 *  bit indicates the end of a stream.
 *
 * @Warning: Members of this class are kept public for compatibility issues with
 *  the legacy code.
 *
 *******************************************************************************/
#ifdef __SYNTHESIS__
struct AxisRaw {
#else
class AxisRaw {
  protected:
#endif

    LE_tData    tdata;
    LE_tKeep    tkeep;
    LE_tLast    tlast;

    // Return the number of valid bytes // [FIXME] Must be f(ARW/8)
    int keepToLen() const {
        switch(this->tkeep){
            case 0x01: return 1; break;
            case 0x03: return 2; break;
            case 0x07: return 3; break;
            case 0x0F: return 4; break;
            case 0x1F: return 5; break;
            case 0x3F: return 6; break;
            case 0x7F: return 7; break;
            case 0xFF: return 8; break;
        }
        return 0;
    }

#ifndef __SYNTHESIS__
  private:
#endif

    // Zero the bytes which have their tkeep-bit cleared
    void clearUnusedBytes() {
        for (int i=0, hi=ARW/8-1, lo=0; i<ARW/8; i++) {  // ARW/8 = noBytes
            #pragma HLS UNROLL
            if (tkeep[i] == 0) {
                tdata.range(hi+8*i, lo+8*i) = 0x00;
            }
        }
    }
    // Reverse the bits within a nibble.
    ap_uint<4>  bitSwap4(ap_uint<4> inputVector) const {
    	return (inputVector.range(0,3));
    }
    // Reverse the bits within a byte.
    ap_uint<8>  bitSwap8(ap_uint<8> inputVector) const {
    	return (inputVector.range(0,7));
    }
    // Swap the two bytes of a word (.i.e, 16 bits).
    ap_uint<16> byteSwap16(ap_uint<16> inputVector) const {
    	return (inputVector.range(7,0), inputVector(15, 8));
    }
    // Swap the four bytes of a double-word (.i.e, 32 bits).
    ap_uint<32> byteSwap32(ap_uint<32> inpDWord) const {
    	return (inpDWord.range( 7, 0), inpDWord.range(15,  8),
    			inpDWord.range(23,16), inpDWord.range(31, 24));
    }
    // Swap the eight bytes of a quad-word (.i.e, 64 bits).
    ap_uint<64> byteSwap64(ap_uint<64> inpQWord) const {
    	return (inpQWord.range( 7, 0), inpQWord(15,  8),
    			inpQWord.range(23,16), inpQWord(31, 24),
				inpQWord.range(39,32), inpQWord(47, 40),
				inpQWord.range(55,48), inpQWord(63, 56));
    }

#ifndef __SYNTHESIS__
    public:
#endif
    AxisRaw()       {}
    AxisRaw(LE_tData tdata, LE_tKeep tkeep, LE_tLast tlast) :
            tdata(tdata), tkeep(tkeep), tlast(tlast) {}

    /******************************************************
     * BIG-ENDIAN GETTERS & SETTERS
     ******************************************************/
    // Return 'tdata' field in Big-Endian order
    tData getTData() const { return byteSwap64(tdata.range(63, 0)); }
    // Return 'tkeep' field in Big-Endian order
    tKeep getTKeep() const { return bitSwap8(tkeep); }
    // Return 'tlast' bit
    tLast getTLast() const { return tlast; }

    // Set 'tdata' field with a 'data' encoded in Big-Endian order
    void setTData(const tData data) { tdata.range(63,  0) = byteSwap64(data); }
    // Set 'tkeep' field with a 'keep' encoded in Big-Endian order
    void setTKeep(const tKeep keep) { tkeep = bitSwap8(keep); }
    // Set 'tlast' field
    void setTLast(const tLast last) { tlast = last;
        if (last) {
            // Always zero the bytes which have their tkeep-bit cleared.
            // This simplifies the computation of the various checksums and
            // unifies the overall AxisRaw processing and verification.
            this->clearUnusedBytes();
        }
    }

    /******************************************************
     * LITTLE-ENDIAN GETTERS & SETTERS
     ******************************************************/
    // Return 'tdata' field in Little-Endian order
    LE_tData getLE_TData(int hi=ARW-1,   int lo=0) const { return tdata.range(hi, lo); }
    // Return 'tkeep' field in Little-Endian order
    LE_tKeep getLE_TKeep(int hi=ARW/8-1, int lo=0) const { return tkeep.range(hi, lo); }
    // Return 'tlast' bit
    LE_tLast getLE_TLast()                         const { return tlast; }

    // Return upper-half of 'tdata' in Little-Endian order (i.e. tdata(31,0))
    LE_tDataHalf getLE_TDataHi() const { return getLE_TData().range(31,  0); } // [FIXME] getLE_TData(31,0)
    // Return lower-half of 'tdata' in Little-Endian order (i.e. tdata(63,32))
    LE_tDataHalf getLE_TDataLo() const { return getLE_TData().range(63, 32); } // [FIXME]

    // Set 'tdata' field with a 'data' encoded in Little-Endian order
    void setLE_TData(const LE_tData data, int hi=ARW-1,   int lo=0) { tdata.range(hi, lo) = data.range(hi-lo, 0); }
    // Set 'tkeep' field with a 'keep' encoded in Little-Endian order
    void setLE_TKeep(const LE_tKeep keep, int hi=ARW/8-1, int lo=0) { tkeep.range(hi, lo) = keep; }
    // Set the tlast field
    void setLE_TLast(const LE_tLast last)                           { tlast = last; }

    // Set upper-half part of 'tdata' (i.e. data(31, 0) with a 'data' encoded in Little-Endian order
    void setLE_TDataHi(const LE_tData data) { tdata.range(31,  0) = data.range(31,  0); }  // [FIXME] setLE_TData(data, 31, 0)
    // Set lower-half part of 'tdata' (i.e. data(63,32) with a 'data' encoded in Little-Endian order
    void setLE_TDataLo(const LE_tData data) { tdata.range(63, 32) = data.range(63, 32); }  // [FIXME]

    // Get the length of this chunk (in bytes)
    int getLen() const {
        return keepToLen();
    }
    // Assess the consistency of 'tkeep' and 'tlast'
    bool isValid() const {
        if (((this->tlast == 0) and (this->tkeep != 0xFF)) or  // [FIXME] Must be f(ARW/8)
            ((this->tlast == 1) and (this->keepToLen() == 0))) {
            return false;
        }
        return true;
    }

};

#endif

/*! \} */
