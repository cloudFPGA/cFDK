/*
 * Copyright 2016 -- 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*****************************************************************************
 * @file       : AxisPsd4.hpp
 * @brief      : A class to access the fields of a TCP/IPv4 or UDP/IPv4 pseudo
 *               packet when transmitted over an AXI4-Stream interface.
 *
 * System:     : cloudFPGA
 * Component   : Shell, Network Transport Stack (NTS)
 * Language    : Vivado HLS
 *
 * \ingroup NTS
 * \addtogroup NTS
 * \{
 *----------------------------------------------------------------------------
 *
 * @details : The TCP/UDP pseudo IPv4 packet fields defined in this class
 *  refer tp the format generated by the 10GbE MAC of Xilinx which organizes
 *  its two 64-bit Rx and Tx interfaces into 8 lanes (see PG157). 
 *  The result of this division into lanes, is that the ETH fields end up
 *  being stored in LITTLE-ENDIAN order instead of the initial big-endian
 *  order used to transmit bytes over the physical media.
 *  As an example, assume that the 16-bits field "TotalLength" of an IPv4
 *  packet has a value of '0x1234'. This field will be transmitted on the
 *  media in big-endian order .i.e, a '0x12' followed by '0x34'. However,
 *  this field will end up being ordered in little-endian mode (.i.e, 0x3412)
 *  by the AXI4-Stream interface of the 10GbE MAC.
 *
 *  Therefore, the mapping of a pseudo IPv4 packet onto an  AXI4-Stream
 *  interface encoded in LITTLE-ENDIAN is as follows:
 *
 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Destination Address                        |                       Source Address                          |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *                                                                  |       UDP or TCP Length       |    Protocol   |     0x00      |    
 *                                                                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * 
 *  And the format of a TCP segment over a pseudo IPV4 packet is as follow:
 *
 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Destination Address                        |                       Source Address                          |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |       Destination Port        |          Source Port          |       UDP or TCP Length       |    Protocol   |     0x00      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Acknowledgment Number                      |                        Sequence Number                        |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                               |                               |                               |   |U|A|P|R|S|F|  Data |       |
 *  |         Urgent Pointer        |           Checksum            |            Window             |   |R|C|S|S|Y|I| Offset|  Res  |
 *  |                               |                               |                               |   |G|K|H|T|N|N|       |       |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                                                             Data                                                              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *  And the format of a UDP datagram over a pseudo IPv4 packet is as follows:

 *         6                   5                   4                   3                   2                   1                   0
 *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Destination Address                        |                       Source Address                          |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |       Destination Port        |          Source Port          |       UDP or TCP Length       |    Protocol   |     0x00      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                             Data                              |           Checksum            |           Length              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                                                             Data                                                              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *****************************************************************************/

#ifndef _AXIS_PSD4_H_
#define _AXIS_PSD4_H_

#include "./AxisRaw.hpp"
#include "./AxisTcp.hpp"

/***********************************************************
 * PSD4 - PSEUDO-HEADER LENGTH
 *  A pseudo IP4 packet has a default header len of 12 bytes.
 ***********************************************************/
#define PSD4_HEADER_LEN      12      // In bytes

/***********************************************************
 * PSD4 - PSEUDO-HEADER FIELDS IN NETWORK BYTE ORDER
 ***********************************************************/
typedef ap_uint< 8> Psd4Res;           // Pseudo-Header Reserved Bits
//typedef ap_uint<16> Psd4Len;           // Pseudo-Header UDP datagram or TCP segment Length

/******************************************************************************
 * PSD4 - PSEUDO-IPv4 Packet over AXI4-STREAMING
 *  As Encoded by the 10GbE MAC (.i.e LITTLE-ENDIAN order).
 *******************************************************************************/
class AxisPsd4: public AxisRaw {

  public:
    AxisPsd4() {}
    AxisPsd4(AxisRaw &axisRaw) :
        AxisRaw(axisRaw.getLE_TData(), axisRaw.getLE_TKeep(), axisRaw.getLE_TLast()) {}
    AxisPsd4(LE_tData tdata, LE_tKeep tkeep, LE_tLast tlast) :
        AxisRaw(tdata, tkeep, tlast) {}
    AxisPsd4(const AxisPsd4 &axisPsd4) :
        AxisRaw(axisPsd4.tdata, axisPsd4.tkeep, axisPsd4.tlast) {}

    /****************************************************************
     * TCP/IPv4 PSEUDO HEADER HELPERS
     ****************************************************************/

    // Set-Get the PSD4 Source Address
    void        setPsd4SrcAddr(Ip4Addr addr)    {                  tdata.range(31,  0) = swapDWord(addr); }
    Ip4Addr     getPsd4SrcAddr()                { return swapDWord(tdata.range(31,  0));                  }
    // Set-Get the PSD4 Destination Address
    void        setPsd4DstAddr(Ip4Addr addr)    {                  tdata.range(63, 32) = swapDWord(addr); }
    Ip4Addr     getPsd4DstAddr()                { return swapDWord(tdata.range(63, 32));                  }
    // Set-Get the PSD4 Reserved Bits
    void        setPsd4ResBits(Psd4Res res)     {                  tdata.range( 7,  0) = res;             }
    Psd4Res     getPsd4ResBits()                {           return tdata.range( 7,  0);                   }
    // Set-Get the PSD4 Protocol
    void        setPsd4Prot(Ip4Prot prot)       {                  tdata.range(15,  8) = prot;            }
    Ip4Prot     getPsd4Prot()                   {           return tdata.range(15,  8);                   }
    // Set-Get the PSD4 LY4 Length
    void        setPsd4Len(Ly4Len len)          {                  tdata.range(31, 16) = swapWord(len);   }
    Ly4Len      getPsd4Len()                    { return swapWord (tdata.range(31, 16));                  }

    //-----------------------------------------------------
    //-- ENCAPSULATED TCP SEGMENT - Setters and Getters
    //-----------------------------------------------------
    // Set-Get the TCP Source Port
    void        setTcpSrcPort(TcpPort port)     {                  tdata.range(47, 32) = swapWord(port);  }
    TcpPort     getTcpSrcPort()                 { return swapWord (tdata.range(47, 32));                  }
    // Set-Get the TCP Destination Port
    void        setTcpDstPort(TcpPort port)     {                  tdata.range(63, 48) = swapWord(port);  }
    TcpPort     getTcpDstPort()                 { return swapWord (tdata.range(63, 48));                  }
    // Set-Get the TCP Sequence Number
    void        setTcpSeqNum(TcpSeqNum num)     {                  tdata.range(31,  0) = swapDWord(num);  }
    TcpSeqNum   getTcpSeqNum()                  { return swapDWord(tdata.range(31,  0));                  }
    // Set-Get the TCP Acknowledgment Number
    void        setTcpAckNum(TcpAckNum num)     {                  tdata.range(63, 32) = swapDWord(num);  }
    TcpAckNum   getTcpAckNum()                  { return swapDWord(tdata.range(63, 32));                  }
    // Set-Get the TCP ECN-Nonce bit
    void setTcpCtrlNs(TcpCtrlBit bit)           {                  tdata.bit( 0) = bit;                   }
    TcpCtrlBit  getTcpCtrlNs()                  {           return tdata.bit( 0);                         }
    // Set-Get the TCP Reserved bits
    void        setTcpResBits(TcpResBits res)   {                  tdata.range( 3,  1) = res;             }
    TcpResBits  getTcpResBits()                 { return           tdata.range( 3,  1);                   }
    // Set-Get the TCP Data Offset
    void        setTcpDataOff(TcpDataOff offset){                  tdata.range( 7,  4) = offset;          }
    TcpDataOff  getTcpDataOff()                 { return           tdata.range( 7,  4);                   }
    // Set-Get the TCP Control Bits
    void setTcpCtrlFin(TcpCtrlBit bit)          {                  tdata.bit( 8) = bit;                   }
    TcpCtrlBit  getTcpCtrlFin()                 {           return tdata.bit( 8);                         }
    void setTcpCtrlSyn(TcpCtrlBit bit)          {                  tdata.bit( 9) = bit;                   }
    TcpCtrlBit  getTcpCtrlSyn()                 {           return tdata.bit( 9);                         }
    void setTcpCtrlRst(TcpCtrlBit bit)          {                  tdata.bit(10) = bit;                   }
    TcpCtrlBit  getTcpCtrlRst()                 {           return tdata.bit(10);                         }
    void setTcpCtrlPsh(TcpCtrlBit bit)          {                  tdata.bit(11) = bit;                   }
    TcpCtrlBit  getTcpCtrlPsh()                 {           return tdata.bit(11);                         }
    void setTcpCtrlAck(TcpCtrlBit bit)          {                  tdata.bit(12) = bit;                   }
    TcpCtrlBit  getTcpCtrlAck()                 {           return tdata.bit(12);                         }
    void setTcpCtrlUrg(TcpCtrlBit bit)          {                  tdata.bit(13) = bit;                   }
    TcpCtrlBit  getTcpCtrlUrg()                 {           return tdata.bit(13);                         }
    void setTcpCtrlEce(TcpCtrlBit bit)          {                  tdata.bit(14) = bit;                   }
    TcpCtrlBit  getTcpCtrlEce()                 {           return tdata.bit(14);                         }
    void setTcpCtrlCwr(TcpCtrlBit bit)          {                  tdata.bit(15) = bit;                   }
    TcpCtrlBit  getTcpCtrlCwr()                 {           return tdata.bit(15);                         }
    // Set-Get the TCP Window
    void        setTcpWindow(TcpWindow win)     {                  tdata.range(31, 16) = swapWord(win);   }
    TcpWindow   getTcpWindow()                  { return swapWord (tdata.range(31, 16));                  }
    // Set-Get the TCP Checksum
    void        setTcpChecksum(TcpChecksum csum){                  tdata.range(47, 32) = swapWord(csum);  }
    TcpChecksum getTcpChecksum()                { return swapWord (tdata.range(47, 32));                  }
    // Set-Get the TCP Urgent Pointer
    void        setTcpUrgPtr(TcpUrgPtr ptr)     {                  tdata.range(63, 48) = swapWord(ptr);   }
    TcpUrgPtr   getTcpUrgPtr()                  { return swapWord (tdata.range(63, 48));                  }
    // Set-Get the TCP Options
    void        setTcpOptKind(TcpOptKind val)   {                  tdata.range( 7,  0) = val;             }
    TcpOptKind  getTcpOptKind()                 { return           tdata.range( 7,  0);                   }
    // Set-Get the TCP Options
    void        setTcpOptLen(TcpOptLen   len)   {                  tdata.range(15,  8) = len;             }
    TcpOptLen   getTcpOptLend()                 { return           tdata.range(15,  8);                   }
    void        setTcpOptMss(TcpOptMss val)     {                  tdata.range(31, 16) = swapWord(val);   }
    TcpOptMss   getTcpOptMss()                  { return swapWord (tdata.range(31, 16));                  }

    LE_TcpPort  getLE_TcpSrcPort()              {           return tdata.range(47, 32) ;                  }
    LE_TcpPort  getLE_TcpDstPort()              {           return tdata.range(63, 48);                   }

    //-----------------------------------------------------
    //-- ENCAPSULATED UDP DATAGRAM - Setters and Getters
    //-----------------------------------------------------
    // Set-Get the UDP Source Port
    void        setUdpSrcPort(UdpPort port)     {                  tdata.range(47, 32) = swapWord(port);  }
    UdpPort     getUdpSrcPort()                 { return swapWord (tdata.range(47, 32));                  }
    // Set-Get the UDP Destination Port
    void        setUdpDstPort(UdpPort port)     {                  tdata.range(63, 48) = swapWord(port);  }
    UdpPort     getUdpDstPort()                 { return swapWord (tdata.range(63, 48));                  }
    // Set-Get the UDP Length
    void        setUdpLen(UdpLen len)           {                  tdata.range(15,  0) = swapWord(len);   }
    UdpLen      getUdpLen()                     { return swapWord (tdata.range(15,  0));                  }
    // Set-Get the UDP Checksum
    void        setUdpCsum(UdpCsum csum)        {                  tdata.range(31, 16) = swapWord(csum);  }
    TcpChecksum getUdpCsum()                    { return swapWord (tdata.range(31, 16));                  }

  private:
    // Reverse the bits within a nibble.
    ap_uint<4> swapNibble(ap_uint<4> nibble) {
        return (nibble.range(0,3));
    }
    // Swap the two bytes of a word (.i.e, 16 bits)
    ap_uint<16> swapWord(ap_uint<16> inpWord) {
        return (inpWord.range(7,0), inpWord.range(15, 8));
    }
    // Swap the four bytes of a double-word (.i.e, 32 bits)
    ap_uint<32> swapDWord(ap_uint<32> inpDWord) {
        return (inpDWord.range( 7, 0), inpDWord.range(15,  8),
                inpDWord.range(23,16), inpDWord.range(31, 24));
    }
    // Swap the eight bytes of a quad-word (.i.e, 64 bits)
    ap_uint<64> swapQWord(ap_uint<64> inpQWord) {
        return (inpQWord.range( 7, 0), inpQWord.range(15,  8),
                inpQWord.range(23,16), inpQWord.range(31, 24),
                inpQWord.range(39,32), inpQWord.range(47, 40),
                inpQWord.range(55,48), inpQWord.range(63, 56));
    }

}; // End of: AxisPsd4

#endif

/*! \} */
